# referenes
# https://blog.zachinachshon.com/cert-manager/
# Prepare 
kubectl get nodes --show-labels

# Add a label to the master node
kubectl label nodes k3main node-type=master

# Verify 
kubectl get nodes --show-labels | grep node-type

# Create cert manager namespace
kubectl create namespace cert-manager

# Disable resource validation 
kubectl label namespace cert-manager certmanager.k8s.io/disable-validation=true

# Add the helm repo 
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm search repo cert-manager

# Install cert-manager
helm upgrade --install cert-manager --namespace cert-manager --set nodeSelector.node-type=master --set webhook.nodeSelector.node-type=master --set cainjector.nodeSelector.node-type=master  jetstack/cert-manager --set installCRDs=true

# Verify 
# Make sure all cert-manager deployed pods are running
kubectl get pods --namespace cert-manager
   
# Make sure custom resources *.cert-manager.io were created successfully 
kubectl get crd | grep cert-manager
    
# Verify that ClusterIssuer is non-namespaced scoped ('false')
# so it can be used to issue Certificates across all namespaces
kubectl api-resources | grep clusterissuers

# Optional if necessary - Reset / uninstall
helm uninstall cert-manager --namespace cert-manager
# clear the namespace 
kubectl delete namespaces cert-manager

# Issuer 
# We are using self signed certs for our lab but this can also work with a ca provider
cat <<EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: cluster-ca-issuer
spec:
  selfSigned: {}
EOF

# wait for cluster to become ready
kubectl get clusterissuers cluster-ca-issuer -o wide

## Certificate
cat <<EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: lab-cert
  namespace: cert-manager
spec:
  secretName: lab-cert-secret
  isCA: true
  commonName: '*.smrtrock.com'
  dnsNames:
    - smrtrock.com
    - '*.smrtrock.com'
  privateKey:
    size: 2048
    algorithm: RSA
  issuerRef:
    name: cluster-ca-issuer
    kind: ClusterIssuer
EOF
### check cert 
kubectl describe certificate traefik-cert --namespace traefik-

# Optional when needed delete certs
# Delete certificate
kubectl delete certificate MY_DOMAIN-com-cert --namespace MY_NAMESPACE
   
# Delete the auto generated secret
kubectl delete secret MY_DOMAIN-com-cert-secret --namespace MY_NAMESPACE


# Now we need to get traefik to use the secret we just created
cat <<EOF | kubectl apply -f -
---
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: traefik-dashboard
  namespace: traefik
spec:
  entryPoints:
    - web
    - websecure
  routes:
    - match: Host(\`traefik.smrtrock.com\`)
      kind: Rule
      services:
        - name: api@internal
          kind: TraefikService
      middlewares:
        - name: auth
  # Use the secret generated by cert-manager
  tls:
    secretName: traefik-cert-secret
EOF

# Secrets
## Create local destination folder
mkdir -p $HOME/temp/traefik/cert-secrets
export MY_DOMAIN=smrtrock
export MY_NAMESPACE=traefik

## Export cert secrets
### cert_file
kubectl get secret traefik-cert-secret  \
   --namespace ${MY_NAMESPACE} \
   -o jsonpath='{.data.tls\.crt}' | base64 -d \
   > $HOME/temp/${MY_NAMESPACE}/cert-secrets/cert_file.crt
### key_file
kubectl get secret traefik-cert-secret \
   --namespace ${MY_NAMESPACE} \
   -o jsonpath='{.data.tls\.key}' | base64 -d \
   > $HOME/temp/${MY_NAMESPACE}/cert-secrets/key_file.key
### ca cert
kubectl get secret traefik-cert-secret \
   --namespace ${MY_NAMESPACE} \
   -o jsonpath='{.data.ca\.crt}' | base64 -d \
   > $HOME/temp/${MY_NAMESPACE}/cert-secrets/ca_file.crt
#### Verify exported correctly
ls -lah $HOME/temp/traefik/cert-secrets
#### clear the variables
unset MY_DOMAIN MY_NAMESPACE

# TRUST 
# On windows double click the ca cert and add it to the trusted root

# Sharing Secrets between namespaces 
kubectl get secret traefik-cert-secret -n traefik -o yaml \
| sed s/"namespace: traefik"/"namespace: media"/\
| kubectl apply -n media -f -
